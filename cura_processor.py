import os
import logging
import asyncio
import subprocess
import json
from pathlib import Path
from typing import Optional, Tuple, Dict

logger = logging.getLogger("uvicorn.error")

# Environment variables
CURAENGINE_PATH = os.getenv("CURAENGINE_PATH", "").strip()
CURA_DEFINITION_JSON = os.getenv("CURA_DEFINITION_JSON", "").strip()
CURA_TIMEOUT = int(os.getenv("CURA_TIMEOUT", "300"))  # 5 minutes default
CURA_VERBOSE = os.getenv("CURA_VERBOSE", "true").lower() == "true"

OUTPUT_DIR_RAW = os.getenv("OUTPUT_DIR", "./output").strip()
OUTPUT_DIR = Path(OUTPUT_DIR_RAW)

logger.info(
    "[CuraCfg] path=%s definition=%s timeout=%ds verbose=%s",
    CURAENGINE_PATH or "(not configured)",
    CURA_DEFINITION_JSON or "(not configured)",
    CURA_TIMEOUT,
    CURA_VERBOSE,
)


# Default slicing settings for 3D printing (PLA on Ender3 Pro)
DEFAULT_CURA_SETTINGS = {
    # Basic print settings
    "layer_height": "0.2",
    "wall_line_count": "3",
    "wall_thickness": "1.2",
    "top_thickness": "0.8",
    "bottom_thickness": "0.8",
    "top_layers": "4",
    "bottom_layers": "4",

    # Infill
    "infill_sparse_density": "20",
    "infill_pattern": "grid",
    "infill_overlap": "30",

    # Speed (mm/s)
    "speed_print": "50",
    "speed_infill": "60",
    "speed_wall": "40",
    "speed_wall_0": "30",  # Outer wall
    "speed_wall_x": "40",  # Inner walls
    "speed_topbottom": "40",
    "speed_travel": "150",
    "speed_layer_0": "20",  # First layer

    # Temperature (Â°C)
    "material_print_temperature": "200",
    "material_bed_temperature": "60",
    "material_print_temperature_layer_0": "205",
    "material_bed_temperature_layer_0": "60",

    # Support
    "support_enable": "false",
    "support_type": "buildplate",
    "support_angle": "50",
    "support_infill_rate": "20",
    "support_z_distance": "0.2",

    # Adhesion
    "adhesion_type": "skirt",
    "skirt_line_count": "3",
    "skirt_gap": "3",
    "brim_width": "8",

    # Retraction
    "retraction_enable": "true",
    "retraction_amount": "5",
    "retraction_speed": "45",
    "retraction_retract_speed": "45",
    "retraction_prime_speed": "45",

    # Cooling
    "cool_fan_enabled": "true",
    "cool_fan_speed": "100",
    "cool_fan_speed_0": "0",  # First layer
    "cool_min_layer_time": "10",
    "cool_min_speed": "10",

    # Quality
    "optimize_wall_printing_order": "true",
    "fill_outline_gaps": "true",
    "filter_out_tiny_gaps": "false",
    "skin_monotonic": "false",
    "roofing_layer_count": "0",  # Number of top layers with roofing pattern
    "top_layers": "4",  # Number of top layers
    "bottom_layers": "4",  # Number of bottom layers

    # Machine settings (fallback if not in definition)
    "machine_center_is_zero": "false",
    "machine_width": "220",
    "machine_depth": "220",
    "machine_height": "250",
    "machine_nozzle_size": "0.4",
    "line_width": "0.4",
}


def is_curaengine_available() -> bool:
    """Check if CuraEngine is available and configured."""
    if not CURAENGINE_PATH:
        logger.warning("[Cura] CURAENGINE_PATH not configured")
        return False
    if not Path(CURAENGINE_PATH).exists():
        logger.warning("[Cura] CuraEngine not found at: %s", CURAENGINE_PATH)
        return False
    if not CURA_DEFINITION_JSON:
        logger.warning("[Cura] CURA_DEFINITION_JSON not configured")
        return False
    if not Path(CURA_DEFINITION_JSON).exists():
        logger.warning("[Cura] Printer definition not found at: %s", CURA_DEFINITION_JSON)
        return False
    return True


def merge_settings(custom_settings: Optional[Dict[str, str]] = None) -> Dict[str, str]:
    """
    Merge custom settings with default settings.

    Args:
        custom_settings: User-provided settings to override defaults

    Returns:
        Merged settings dictionary
    """
    merged = DEFAULT_CURA_SETTINGS.copy()

    if custom_settings:
        # Validate and merge custom settings
        for key, value in custom_settings.items():
            # Convert all values to strings (CuraEngine requirement)
            merged[key] = str(value)
            logger.info("[Cura] Custom setting: %s=%s", key, value)

    return merged


async def run_curaengine_process(
    stl_path: Path,
    gcode_path: Path,
    settings: Dict[str, str],
) -> Tuple[bool, str]:
    """
    Run CuraEngine to slice STL to G-code.

    Args:
        stl_path: Path to input STL file
        gcode_path: Path to output G-code file
        settings: Dictionary of Cura settings

    Returns:
        Tuple[success: bool, log_output: str]
    """
    logger.info("[Cura] ===== Starting CuraEngine Slicing =====")
    logger.info("[Cura] Input STL: %s (exists: %s)", stl_path, stl_path.exists())
    logger.info("[Cura] Output G-code: %s", gcode_path)
    logger.info("[Cura] Printer definition: %s", CURA_DEFINITION_JSON)
    logger.info("[Cura] Settings count: %d", len(settings))

    if not is_curaengine_available():
        logger.error("[Cura] CuraEngine not available")
        return False, "CuraEngine not configured or not found"

    if not stl_path.exists():
        logger.error("[Cura] STL file not found: %s", stl_path)
        return False, f"STL file not found: {stl_path}"

    # Prepare log file
    log_path = OUTPUT_DIR / f"cura_log_{gcode_path.stem}.txt"
    logger.info("[Cura] Log will be saved to: %s", log_path)

    # Build CuraEngine command
    cmd = [
        str(CURAENGINE_PATH),
        "slice",
    ]

    # Add verbose flag if enabled
    if CURA_VERBOSE:
        cmd.append("-v")

    # Add printer definition
    cmd.extend(["-j", str(Path(CURA_DEFINITION_JSON).absolute())])

    # Add output file
    cmd.extend(["-o", str(gcode_path.absolute())])

    # Add extruder (extruder 0)
    cmd.append("-e0")

    # Add all settings as -s key=value pairs
    for key, value in settings.items():
        cmd.extend(["-s", f"{key}={value}"])

    # Add input STL file (must be last)
    cmd.extend(["-l", str(stl_path.absolute())])

    logger.info("[Cura] Command length: %d arguments", len(cmd))
    if CURA_VERBOSE:
        logger.info("[Cura] Full command: %s", " ".join(cmd))

    # Run CuraEngine process
    try:
        logger.info("[Cura] Starting subprocess with timeout=%ds...", CURA_TIMEOUT)

        # Use sync subprocess for Windows compatibility
        loop = asyncio.get_event_loop()

        def run_subprocess():
            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                )
                stdout, _ = process.communicate(timeout=CURA_TIMEOUT)
                return process.returncode, stdout
            except subprocess.TimeoutExpired:
                process.kill()
                return -1, b"Process timed out"

        returncode, stdout = await loop.run_in_executor(None, run_subprocess)

        logger.info("[Cura] Process completed with return code: %d", returncode)
        logger.info("[Cura] Stdout size: %d bytes", len(stdout))

        log_output = stdout.decode("utf-8", errors="ignore")
        logger.info("[Cura] Decoded output size: %d characters", len(log_output))

        # Save log
        try:
            log_path.write_text(log_output, encoding="utf-8", errors="ignore")
            logger.info("[Cura] Log saved successfully: %s", log_path)
        except Exception as e:
            logger.error("[Cura] Failed to save log: %s", str(e))

        # Check for timeout
        if returncode == -1:
            logger.error("[Cura] Process timed out after %ds", CURA_TIMEOUT)
            return False, "Slicing timeout"

        # CuraEngine may return non-zero even on success (due to warnings)
        # Check if G-code file was actually created
        logger.info("[Cura] Checking output file: %s", gcode_path)
        logger.info("[Cura] Output exists: %s", gcode_path.exists())

        if gcode_path.exists():
            file_size = gcode_path.stat().st_size
            logger.info("[Cura] Output size: %d bytes (%.2f KB)", file_size, file_size / 1024)

            if file_size == 0:
                logger.error("[Cura] G-code file is empty")
                return False, "Generated G-code file is empty"

            # Parse slicing statistics from log
            stats = parse_slicing_stats(log_output)
            logger.info("[Cura] Slicing stats: %s", stats)

            logger.info("[Cura] ===== Slicing Successful =====")
            return True, log_output
        else:
            logger.error("[Cura] G-code file not generated")
            # Extract error messages from log
            error_lines = [line for line in log_output.split('\n') if '[error]' in line.lower()]
            error_summary = '\n'.join(error_lines[-10:]) if error_lines else log_output[-500:]
            logger.error("[Cura] Error summary:\n%s", error_summary)
            return False, error_summary

    except asyncio.CancelledError:
        logger.error("[Cura] Process was cancelled")
        raise
    except Exception as e:
        logger.error("[Cura] Exception during subprocess execution")
        logger.error("[Cura] Exception type: %s", type(e).__name__)
        logger.error("[Cura] Exception message: %s", str(e))
        import traceback
        error_msg = f"CuraEngine execution error: {str(e)}\n{traceback.format_exc()}"
        logger.error("[Cura] Full traceback:\n%s", traceback.format_exc())
        return False, error_msg


def parse_slicing_stats(log_output: str) -> Dict[str, any]:
    """
    Parse useful statistics from CuraEngine log output.

    Args:
        log_output: Full log output from CuraEngine

    Returns:
        Dictionary with statistics (layer_count, print_time, etc.)
    """
    import re
    stats = {}

    try:
        lines = log_output.split('\n')

        for line in lines:
            # Parse layer count
            if 'Processing insets for layer' in line:
                match = re.search(r'layer \d+ of (\d+)', line)
                if match:
                    stats['layer_count'] = int(match.group(1))

            # Parse progress messages
            if '[info] Progress:' in line and 'accomplished in' in line:
                # Extract timing information
                if 'slice accomplished' in line:
                    match = re.search(r'in ([\d.]+)s', line)
                    if match:
                        stats['slice_time'] = float(match.group(1))
                elif 'export accomplished' in line:
                    match = re.search(r'in ([\d.]+)s', line)
                    if match:
                        stats['export_time'] = float(match.group(1))
    except Exception as e:
        logger.warning("[Cura] Failed to parse statistics: %s", str(e))

    return stats


def calculate_gcode_stats_from_content(gcode_path: str) -> Dict[str, any]:
    """
    G-code ë³¸ë¬¸ì ì§ì  íì±íì¬ ì¤ì  ì¶ë ¥ ìê°ê³¼ íë¼ë©í¸ ì¬ì©ë ê³ì°.

    CuraEngineì´ TIMEê³¼ MATERIALì ëë¯¸ê°ì ë£ë ê²½ì°ë¥¼ ëë¹íì¬
    G1 ëªë ¹ì´ë¥¼ ì§ì  ë¶ìí©ëë¤.
    """
    from pathlib import Path

    stats = {
        'calculated_time_seconds': None,
        'calculated_filament_mm': None,
        'calculated_filament_m': None,
        'calculated_filament_g': None,
    }

    try:
        gcode_file = Path(gcode_path)
        if not gcode_file.exists():
            return stats

        total_time_seconds = 0.0
        max_e_value = 0.0
        current_feedrate = 0.0  # mm/min
        last_x, last_y, last_z = 0.0, 0.0, 0.0

        logger.info("[GCodeCalc] Calculating actual time and filament from G-code commands...")

        with open(gcode_file, 'r', encoding='utf-8', errors='ignore') as f:
            for line_num, line in enumerate(f):
                line = line.strip()

                # G1 ì´ë ëªë ¹ íì±
                if line.startswith('G1 '):
                    import re

                    # Feedrate (F) ì¶ì¶
                    f_match = re.search(r'F([\d.]+)', line)
                    if f_match:
                        current_feedrate = float(f_match.group(1))  # mm/min

                    # Extrusion (E) ì¶ì¶ - ìµëê° ì¶ì 
                    e_match = re.search(r'E([\d.\-]+)', line)
                    if e_match:
                        e_value = float(e_match.group(1))
                        if e_value > max_e_value:
                            max_e_value = e_value

                    # ì¢í ì¶ì¶
                    x_match = re.search(r'X([\d.\-]+)', line)
                    y_match = re.search(r'Y([\d.\-]+)', line)
                    z_match = re.search(r'Z([\d.\-]+)', line)

                    x = float(x_match.group(1)) if x_match else last_x
                    y = float(y_match.group(1)) if y_match else last_y
                    z = float(z_match.group(1)) if z_match else last_z

                    # ì´ë ê±°ë¦¬ ê³ì°
                    import math
                    distance = math.sqrt((x - last_x)**2 + (y - last_y)**2 + (z - last_z)**2)

                    # ìê° ê³ì° (distance / feedrate)
                    if current_feedrate > 0 and distance > 0:
                        time_minutes = distance / current_feedrate
                        total_time_seconds += time_minutes * 60

                    last_x, last_y, last_z = x, y, z

        # ê²°ê³¼ ì ì¥
        if total_time_seconds > 0:
            stats['calculated_time_seconds'] = int(total_time_seconds)

        if max_e_value > 0:
            stats['calculated_filament_mm'] = round(max_e_value, 2)
            stats['calculated_filament_m'] = round(max_e_value / 1000.0, 2)

            # ë¬´ê² ê³ì° (1.75mm íë¼ë©í¸, PLA 1.24 g/cmÂ³)
            filament_radius_mm = 1.75 / 2.0
            volume_mm3 = max_e_value * 3.14159 * (filament_radius_mm ** 2)
            volume_cm3 = volume_mm3 / 1000.0
            weight_g = volume_cm3 * 1.24
            stats['calculated_filament_g'] = round(weight_g, 2)

        logger.info("[GCodeCalc] Calculated: time=%ds (%.1fmin), filament=%.2fm (%.2fg)",
                   stats.get('calculated_time_seconds', 0),
                   stats.get('calculated_time_seconds', 0) / 60.0,
                   stats.get('calculated_filament_m', 0),
                   stats.get('calculated_filament_g', 0))

    except Exception as e:
        logger.error("[GCodeCalc] Failed to calculate stats: %s", str(e))

    return stats


def parse_gcode_metadata(gcode_path: str) -> Dict[str, any]:
    """
    G-code íì¼ìì ë©íë°ì´í°ë¥¼ ì¶ì¶í©ëë¤.

    Curaê° ìì±í G-code íì¼ì ì£¼ììì ë¤ì ì ë³´ë¥¼ ì¶ì¶:
    - ì¶ë ¥ ìê° (print_time_seconds, print_time_formatted)
    - íë¼ë©í¸ ì¬ì©ë (filament_used_m, filament_weight_g, filament_cost)
    - ë ì´ì´ ì ë³´ (layer_count, layer_height)
    - ëª¨ë¸ í¬ê¸° (bounding_box: minx, maxx, miny, maxy, minz, maxz)
    - ì¨ë ì¤ì  (nozzle_temp, bed_temp)
    - íë¦°í° ì ë³´ (printer_name)

    Args:
        gcode_path: G-code íì¼ ê²½ë¡

    Returns:
        ëìëë¦¬ ííì ë©íë°ì´í°
    """
    import re
    from pathlib import Path

    metadata = {
        "print_time_seconds": None,
        "print_time_formatted": None,
        "filament_used_m": None,
        "filament_weight_g": None,
        "filament_cost": None,
        "layer_count": None,
        "layer_height": None,
        "bounding_box": {},
        "nozzle_temp": None,
        "bed_temp": None,
        "printer_name": None,
    }

    try:
        gcode_file = Path(gcode_path)
        if not gcode_file.exists():
            logger.warning("[GCodeMeta] File not found: %s", gcode_path)
            return metadata

        # G-code íì¼ì ì¤í¸ë¦¬ë° ë°©ìì¼ë¡ ì½ê¸°
        # íìí ì ë³´ë¥¼ ëª¨ë ì°¾ì¼ë©´ ì¡°ê¸° ì¢ë£íì¬ ì±ë¥ í¥ì
        lines_read = 0

        with open(gcode_file, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                lines_read += 1
                line = line.strip()

                # ëª¨ë  ì£¼ì ë©íë°ì´í°ë¥¼ ì°¾ìëì§ ì²´í¬ (ì¡°ê¸° ì¢ë£ ì¡°ê±´)
                # í¤ë ì ë³´(TIME, MATERIAL ë±)ë ì²ì ë¶ë¶ì ìê³ ,
                # ì¨ë ì ë³´(M104, M140)ë ì¤ê°~íë°ë¶ì ìì¼ë¯ë¡
                # ëª¨ë  ì ë³´ë¥¼ ì°¾ì íìë§ ì¢ë£
                if (lines_read > 100 and  # ìµì 100ì¤ì ì½ê¸°
                    metadata.get('nozzle_temp') is not None and
                    metadata.get('bed_temp') is not None and
                    metadata.get('print_time_seconds') is not None and
                    metadata.get('layer_count') is not None):
                    # ëª¨ë  ì£¼ì ì ë³´ë¥¼ ì°¾ìì¼ë©´ ë ì½ì íì ìì
                    logger.info("[GCodeMeta] All metadata found at line %d, stopping scan", lines_read)
                    break

                # ì¶ë ¥ ìê° (ì´)
                if line.startswith(';TIME:'):
                    match = re.search(r';TIME:(\d+)', line)
                    if match:
                        seconds = int(match.group(1))
                        metadata['print_time_seconds'] = seconds

                        # í¬ë§·ë ìê° ê³ì° (ì: "1h 30m")
                        hours = seconds // 3600
                        minutes = (seconds % 3600) // 60
                        if hours > 0:
                            metadata['print_time_formatted'] = f"{hours}h {minutes}m"
                        else:
                            metadata['print_time_formatted'] = f"{minutes}m"

                # íë¼ë©í¸ ì¬ì©ë (ë¯¸í°) - ì¬ë¬ íì ì§ì
                elif ';Filament used' in line.lower():
                    # Format 1: ";Filament used: 1.23m"
                    match = re.search(r'([\d.]+)\s*m\b', line, re.IGNORECASE)
                    if match:
                        metadata['filament_used_m'] = float(match.group(1))
                    # Format 2: ";Filament used: [1.23]"
                    match = re.search(r'\[([\d.]+)\]', line)
                    if match and metadata['filament_used_m'] is None:
                        metadata['filament_used_m'] = float(match.group(1))

                # íë¼ë©í¸ ë¬´ê² (ê·¸ë¨) - ì¬ë¬ íì ì§ì
                elif ';Filament weight' in line.lower() or ';Filament mass' in line.lower():
                    # Format 1: "weight = 3.64g" or "3.64g"
                    match = re.search(r'([\d.]+)\s*g\b', line, re.IGNORECASE)
                    if match:
                        metadata['filament_weight_g'] = float(match.group(1))
                    # Format 2: "[3.64]"
                    match = re.search(r'\[([\d.]+)\]', line)
                    if match and metadata['filament_weight_g'] is None:
                        metadata['filament_weight_g'] = float(match.group(1))

                # íë¼ë©í¸ ë¹ì©
                elif ';Filament cost' in line.lower():
                    match = re.search(r'([\d.]+)', line)
                    if match:
                        metadata['filament_cost'] = float(match.group(1))

                # MATERIAL (Cura 5.x íì - mmÂ³ ëë cmÂ³)
                elif line.startswith(';MATERIAL:') or line.startswith(';MATERIAL2:'):
                    match = re.search(r';MATERIAL2?:([\d.]+)', line)
                    if match:
                        volume_mm3 = float(match.group(1))
                        # mmÂ³ë¥¼ ë¯¸í°ë¡ ë³í (íë¼ë©í¸ ì§ê²½ 1.75mm ê°ì )
                        # Volume = Ï * rÂ² * length
                        # length = Volume / (Ï * rÂ²)
                        # r = 1.75/2 = 0.875mm
                        filament_radius_mm = 1.75 / 2.0
                        area_mm2 = 3.14159 * (filament_radius_mm ** 2)
                        length_mm = volume_mm3 / area_mm2
                        length_m = length_mm / 1000.0

                        if metadata['filament_used_m'] is None:
                            metadata['filament_used_m'] = round(length_m, 2)

                        # ë¬´ê² ê³ì° (PLA ë°ë: 1.24 g/cmÂ³)
                        if metadata['filament_weight_g'] is None:
                            volume_cm3 = volume_mm3 / 1000.0
                            weight_g = volume_cm3 * 1.24  # PLA ë°ë
                            metadata['filament_weight_g'] = round(weight_g, 2)

                # ë ì´ì´ ì
                elif line.startswith(';LAYER_COUNT:'):
                    match = re.search(r';LAYER_COUNT:(\d+)', line)
                    if match:
                        metadata['layer_count'] = int(match.group(1))

                # ë ì´ì´ ëì´ - ì¬ë¬ íì ì§ì
                elif ';Layer height' in line.lower() or ';LAYER_HEIGHT' in line:
                    # Format 1: ";Layer height: 0.2"
                    match = re.search(r'height[:\s]+([\d.]+)', line, re.IGNORECASE)
                    if match:
                        metadata['layer_height'] = float(match.group(1))
                    # Format 2: ";LAYER_HEIGHT:0.2"
                    match = re.search(r'LAYER_HEIGHT:([\d.]+)', line)
                    if match and metadata['layer_height'] is None:
                        metadata['layer_height'] = float(match.group(1))

                # Bounding Box (ê³¼íì  íê¸°ë² ì§ì: 2.14748e+06)
                elif line.startswith(';MINX:'):
                    match = re.search(r';MINX:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        # ëë¯¸ê° ì²´í¬ (1e6 ì´ìì ë¬´í¨)
                        if abs(value) < 1e6:
                            metadata['bounding_box']['min_x'] = value
                elif line.startswith(';MAXX:'):
                    match = re.search(r';MAXX:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        if abs(value) < 1e6:
                            metadata['bounding_box']['max_x'] = value
                elif line.startswith(';MINY:'):
                    match = re.search(r';MINY:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        if abs(value) < 1e6:
                            metadata['bounding_box']['min_y'] = value
                elif line.startswith(';MAXY:'):
                    match = re.search(r';MAXY:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        if abs(value) < 1e6:
                            metadata['bounding_box']['max_y'] = value
                elif line.startswith(';MINZ:'):
                    match = re.search(r';MINZ:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        if abs(value) < 1e6:
                            metadata['bounding_box']['min_z'] = value
                elif line.startswith(';MAXZ:'):
                    match = re.search(r';MAXZ:([\d.\-+eE]+)', line)
                    if match:
                        value = float(match.group(1))
                        if abs(value) < 1e6:
                            metadata['bounding_box']['max_z'] = value

                # ì¨ë ì¤ì  - ë¸ì¦ (ì£¼ì ëë G-code ëªë ¹ì´ìì)
                elif ';Material print temperature:' in line.lower():
                    match = re.search(r'(\d+)', line)
                    if match and metadata['nozzle_temp'] is None:
                        metadata['nozzle_temp'] = int(match.group(1))

                # ì¨ë ì¤ì  - ë² ë (ì£¼ììì)
                elif ';Material bed temperature:' in line.lower():
                    match = re.search(r'(\d+)', line)
                    if match and metadata['bed_temp'] is None:
                        metadata['bed_temp'] = int(match.group(1))

                # íë¦°í° ì´ë¦
                elif line.startswith(';Printer name:') or line.startswith(';FLAVOR:'):
                    if 'Printer name:' in line:
                        match = re.search(r';Printer name:\s*(.+)', line)
                        if match:
                            metadata['printer_name'] = match.group(1).strip()

                # M104/M109: ë¸ì¦ ì¨ë ì¤ì  (ì: M104 S200)
                elif (line.startswith('M104 ') or line.startswith('M109 ')) and metadata['nozzle_temp'] is None:
                    match = re.search(r'S([\d.]+)', line)
                    if match:
                        temp = int(float(match.group(1)))
                        if temp > 0:  # S0ì ë¬´ì (ëê¸° ëªë ¹)
                            metadata['nozzle_temp'] = temp

                # M140/M190: ë² ë ì¨ë ì¤ì  (ì: M140 S60)
                elif (line.startswith('M140 ') or line.startswith('M190 ')) and metadata['bed_temp'] is None:
                    match = re.search(r'S([\d.]+)', line)
                    if match:
                        temp = int(float(match.group(1)))
                        if temp > 0:  # S0ì ë¬´ì
                            metadata['bed_temp'] = temp

        # ëª¨ë¸ í¬ê¸° ê³ì° (bounding boxê° ìì¼ë©´)
        bbox = metadata['bounding_box']
        has_valid_bbox = False

        # Bounding box ì í¨ì± ì²´í¬
        # 1. ëª¨ë  ê°ì´ ì¡´ì¬íëì§
        # 2. min < max ì¸ì§
        # 3. sizeê° ììì¸ì§
        if (bbox.get('min_x') is not None and bbox.get('max_x') is not None and
            bbox.get('min_y') is not None and bbox.get('max_y') is not None and
            bbox.get('min_z') is not None and bbox.get('max_z') is not None):

            size_x = bbox['max_x'] - bbox['min_x']
            size_y = bbox['max_y'] - bbox['min_y']
            size_z = bbox['max_z'] - bbox['min_z']

            # Sizeê° ëª¨ë ììì¸ì§ íì¸
            if size_x > 0 and size_y > 0 and size_z > 0:
                metadata['bounding_box']['size_x'] = size_x
                metadata['bounding_box']['size_y'] = size_y
                metadata['bounding_box']['size_z'] = size_z
                has_valid_bbox = True
                logger.info("[GCodeMeta] Valid bounding box from G-code: %.2f x %.2f x %.2f mm",
                           size_x, size_y, size_z)
            else:
                logger.warning("[GCodeMeta] Invalid bounding box: negative size detected (X=%.2f, Y=%.2f, Z=%.2f)",
                             size_x, size_y, size_z)
                metadata['bounding_box'] = {}

        if not has_valid_bbox:
            logger.warning("[GCodeMeta] Invalid bounding box detected (dummy values) - will try to extract from STL")

            # STL íì¼ìì ì§ì  í¬ê¸° ì½ê¸°
            stl_path = str(gcode_file).replace('.gcode', '.stl')
            if os.path.exists(stl_path):
                try:
                    import trimesh
                    logger.info("[GCodeMeta] Reading bounding box from STL: %s", stl_path)
                    stl_mesh = trimesh.load(stl_path, file_type='stl')
                    stl_bounds = stl_mesh.bounds

                    metadata['bounding_box'] = {
                        'min_x': round(stl_bounds[0, 0], 2),
                        'max_x': round(stl_bounds[1, 0], 2),
                        'min_y': round(stl_bounds[0, 1], 2),
                        'max_y': round(stl_bounds[1, 1], 2),
                        'min_z': round(stl_bounds[0, 2], 2),
                        'max_z': round(stl_bounds[1, 2], 2),
                        'size_x': round(stl_bounds[1, 0] - stl_bounds[0, 0], 2),
                        'size_y': round(stl_bounds[1, 1] - stl_bounds[0, 1], 2),
                        'size_z': round(stl_bounds[1, 2] - stl_bounds[0, 2], 2),
                    }
                    has_valid_bbox = True
                    logger.info("[GCodeMeta] â Extracted bounding box from STL successfully")
                except Exception as e:
                    logger.warning("[GCodeMeta] Failed to extract bounding box from STL: %s", e)
                    metadata['bounding_box'] = {}
            else:
                logger.warning("[GCodeMeta] STL file not found for bounding box extraction: %s", stl_path)
                metadata['bounding_box'] = {}

        # ëë¯¸ê° ì²´í¬ ë° ì¤ì  ê³ì° ìí
        # TIME:6666 ëë MATERIAL:6666 ê°ì ëë¯¸ê° ê°ì§
        is_dummy_time = (metadata.get('print_time_seconds') == 6666)
        is_dummy_material = (metadata.get('filament_used_m') is None or
                            metadata.get('filament_used_m') == 0 or
                            metadata.get('filament_used_m') > 1000)  # 1km ì´ìì ë¹ì ì

        if is_dummy_time or is_dummy_material:
            logger.warning("[GCodeMeta] Detected dummy/invalid values - calculating from G-code content...")
            calculated_stats = calculate_gcode_stats_from_content(str(gcode_file))

            # ëë¯¸ê°ì¸ ê²½ì° ê³ì°ê°ì¼ë¡ ëì²´
            if is_dummy_time and calculated_stats.get('calculated_time_seconds'):
                metadata['print_time_seconds'] = calculated_stats['calculated_time_seconds']
                seconds = metadata['print_time_seconds']
                hours = seconds // 3600
                minutes = (seconds % 3600) // 60
                if hours > 0:
                    metadata['print_time_formatted'] = f"{hours}h {minutes}m"
                else:
                    metadata['print_time_formatted'] = f"{minutes}m"

            if is_dummy_material:
                if calculated_stats.get('calculated_filament_m'):
                    metadata['filament_used_m'] = calculated_stats['calculated_filament_m']
                if calculated_stats.get('calculated_filament_g'):
                    metadata['filament_weight_g'] = calculated_stats['calculated_filament_g']

        # ë¡ê·¸ ì¶ë ¥
        logger.info("[GCodeMeta] Parsed metadata from: %s", gcode_file.name)
        logger.info("[GCodeMeta]   Print time: %s (%s seconds)",
                   metadata.get('print_time_formatted', 'N/A'),
                   metadata.get('print_time_seconds', 'N/A'))
        logger.info("[GCodeMeta]   Filament: %.2f m, %.2f g",
                   metadata.get('filament_used_m') or 0,
                   metadata.get('filament_weight_g') or 0)
        logger.info("[GCodeMeta]   Layers: %s (height: %s mm)",
                   metadata.get('layer_count', 'N/A'),
                   metadata.get('layer_height', 'N/A'))
        logger.info("[GCodeMeta]   Temperature: Nozzle=%sÂ°C, Bed=%sÂ°C",
                   metadata.get('nozzle_temp', 'N/A'),
                   metadata.get('bed_temp', 'N/A'))

        return metadata

    except Exception as e:
        logger.error("[GCodeMeta] Failed to parse metadata: %s", str(e))
        import traceback
        traceback.print_exc()
        return metadata


async def convert_stl_to_gcode(
    stl_path: str,
    gcode_path: str,
    custom_settings: Optional[Dict[str, str]] = None,
    printer_definition_path: Optional[str] = None,
) -> bool:
    """
    Convert STL file to G-code using CuraEngine.

    Args:
        stl_path: Absolute path to input STL file
        gcode_path: Absolute path to output G-code file
        custom_settings: Optional dictionary of custom Cura settings
        printer_definition_path: Optional path to printer definition JSON
                                (if None, uses CURA_DEFINITION_JSON from env)

    Returns:
        bool: Success status
    """
    if not is_curaengine_available():
        raise RuntimeError("CuraEngine is not configured or not available")

    stl_file = Path(stl_path)
    gcode_file = Path(gcode_path)

    if not stl_file.exists():
        raise RuntimeError(f"Input STL file not found: {stl_path}")

    # Merge settings
    settings = merge_settings(custom_settings)

    # Override printer definition if provided
    global CURA_DEFINITION_JSON
    if printer_definition_path:
        if not Path(printer_definition_path).exists():
            raise RuntimeError(f"Printer definition not found: {printer_definition_path}")
        # Temporarily override
        original_def = CURA_DEFINITION_JSON
        CURA_DEFINITION_JSON = printer_definition_path
        logger.info("[Cura] Using custom printer definition: %s", printer_definition_path)

    try:
        # Run slicing
        logger.info("[Cura] Starting slicing: %s -> %s", stl_path, gcode_path)
        success, log_output = await run_curaengine_process(
            stl_file,
            gcode_file,
            settings,
        )

        if not success:
            raise RuntimeError(f"Slicing failed: {log_output[:500]}")

        logger.info("[Cura] Slicing completed successfully")
        return True

    finally:
        # Restore original definition if it was overridden
        if printer_definition_path:
            CURA_DEFINITION_JSON = original_def


async def convert_stl_to_gcode_with_printer_name(
    stl_path: str,
    gcode_path: str,
    printer_name: str,
    custom_settings: Optional[Dict[str, str]] = None,
) -> bool:
    """
    Convert STL to G-code using printer name from Cura definitions directory.

    Args:
        stl_path: Path to input STL file
        gcode_path: Path to output G-code file
        printer_name: Printer def file name (e.g., 'creality_ender3pro')
        custom_settings: Optional dict of Cura setting overrides

    Returns:
        bool: True if slicing succeeded, False otherwise
    """
    # Cura definitions directory
    # CURAENGINE_PATH = C:\Program Files\UltiMaker Cura 5.7.1\CuraEngine.exe
    # definitions_dir = C:\Program Files\UltiMaker Cura 5.7.1\share\cura\resources\definitions
    curaengine_path = Path(os.getenv("CURAENGINE_PATH", ""))
    cura_root = curaengine_path.parent  # C:\Program Files\UltiMaker Cura 5.7.1
    definitions_dir = cura_root / "share" / "cura" / "resources" / "definitions"

    # Find printer def file (remove .def if already in printer_name)
    if printer_name.endswith(".def"):
        printer_name = printer_name[:-4]  # Remove '.def'

    printer_def_path = definitions_dir / f"{printer_name}.def.json"

    if not printer_def_path.exists():
        logger.error("[Cura] Printer definition not found: %s", printer_def_path)
        return False

    logger.info("[Cura] Using printer definition: %s", printer_name)
    logger.info("[Cura] Def file path: %s", printer_def_path)

    # Temporarily override CURA_DEFINITION_JSON
    global CURA_DEFINITION_JSON
    original_def = CURA_DEFINITION_JSON
    CURA_DEFINITION_JSON = str(printer_def_path)

    try:
        # Use convert_stl_to_gcode which will use the overridden def path
        result = await convert_stl_to_gcode(
            stl_path=stl_path,
            gcode_path=gcode_path,
            custom_settings=custom_settings,
        )
        return result
    finally:
        # Restore original definition
        CURA_DEFINITION_JSON = original_def


async def convert_stl_to_gcode_with_definition(
    stl_path: str,
    gcode_path: str,
    printer_definition: Dict[str, any],
    custom_settings: Optional[Dict[str, str]] = None,
) -> bool:
    """
    Convert STL to G-code using printer definition JSON sent by client.

    ì´ í¨ìë íì¬ ë³µì¡í íë¦°í° ì ì ìì ë¬¸ì ë¡ ì¸í´ í­ì ì¤í¨í©ëë¤.
    ëì  main.pyì fallback ë¡ì§ì´ ìëíì¬ fdmprinter + bed sizeë¡ ì¬ìëí©ëë¤.

    Args:
        stl_path: Absolute path to input STL file
        gcode_path: Absolute path to output G-code file
        printer_definition: Complete printer definition JSON (dict from .def.json file)
        custom_settings: Optional user settings to override defaults

    Returns:
        bool: Success status
    """
    logger.warning("[Cura] convert_stl_to_gcode_with_definition() called - will raise exception for fallback")
    logger.info("[Cura] Printer definition keys: %s", list(printer_definition.keys()))

    # ì´ í¨ìë ìëì ì¼ë¡ ì¤í¨íì¬ fallbackì´ ìëíëë¡ í¨
    raise RuntimeError("Custom printer definition not supported - use fallback to fdmprinter + bed size")

    # Write printer definition to temporary file in Cura definitions directory
    # This allows CuraEngine to resolve inheritance
    import tempfile
    import json
    import shutil

    # Get Cura definitions directory
    curaengine_path = Path(os.getenv("CURAENGINE_PATH", ""))
    cura_root = curaengine_path.parent
    definitions_dir = cura_root / "share" / "cura" / "resources" / "definitions"

    if not definitions_dir.exists():
        raise RuntimeError(f"Cura definitions directory not found: {definitions_dir}")

    # Create temp file in definitions directory so inheritance works
    temp_def_file = tempfile.NamedTemporaryFile(
        mode='w',
        suffix='.def.json',
        delete=False,
        dir=definitions_dir,  # ì¤ì: definitions ëë í ë¦¬ì ìì±
        prefix='temp_client_'
    )

    try:
        # ì ëµ: fdmprinterë¥¼ baseë¡ ì¬ì©íê³  í´ë¼ì´ì¸í¸ overrides ì ì©
        # CuraEngineì ììì ì§ìíë¯ë¡ í´ë¼ì´ì¸í¸ ì ìê° fdmprinterë¥¼ ììíëë¡ í¨

        # í´ë¼ì´ì¸í¸ê° overridesë§ ë³´ë¸ ê²½ì° -> ìì í ì ìë¡ ë³í
        client_overrides = {}

        if 'overrides' in printer_definition:
            logger.info("[Cura] Client provided %d overrides", len(printer_definition['overrides']))
            client_overrides = printer_definition['overrides']

        # í´ë¼ì´ì¸í¸ê° settingsë¥¼ ë³´ë¸ ê²½ì°ë overridesë¡ ì²ë¦¬
        if 'settings' in printer_definition and printer_definition['settings']:
            logger.info("[Cura] Client provided %d settings", len(printer_definition['settings']))
            # settingsë¥¼ overrides íìì¼ë¡ ë³í
            for key, value in printer_definition['settings'].items():
                if isinstance(value, dict) and 'default_value' in value:
                    client_overrides[key] = value
                else:
                    # ê°ë§ ì ê³µë ê²½ì° default_value íìì¼ë¡ ë³í
                    client_overrides[key] = {'default_value': value}

        # fdmprinterë¥¼ ììíë ì ì ì ìì±
        custom_definition = {
            "version": 2,
            "name": printer_definition.get('name', 'Custom Printer'),
            "inherits": "fdmprinter",  # CuraEngineì´ ê°ì ëë í ë¦¬ìì fdmprinter ì°¾ì
            "metadata": {
                "visible": True,
                "type": "machine"
            },
            "overrides": client_overrides
        }

        # ë©íë°ì´í° ë³í©
        if 'metadata' in printer_definition:
            custom_definition['metadata'].update(printer_definition['metadata'])

        logger.info("[Cura] Created definition inheriting from fdmprinter with %d overrides",
                   len(client_overrides))

        # Write definition JSON
        json.dump(custom_definition, temp_def_file, indent=2)
        temp_def_file.close()
        definition_path = temp_def_file.name

        logger.info("[Cura] Created temporary printer definition in Cura directory: %s", definition_path)

        # Merge settings
        settings = merge_settings(custom_settings)

        # Temporarily override CURA_DEFINITION_JSON
        global CURA_DEFINITION_JSON
        original_def = CURA_DEFINITION_JSON
        CURA_DEFINITION_JSON = definition_path

        try:
            # Run slicing
            logger.info("[Cura] Starting slicing with client definition")
            success, log_output = await run_curaengine_process(
                stl_file,
                gcode_file,
                settings,
            )

            if not success:
                raise RuntimeError(f"Slicing failed: {log_output[:500]}")

            logger.info("[Cura] Slicing completed successfully")
            return True

        finally:
            # Restore original definition
            CURA_DEFINITION_JSON = original_def

    finally:
        # Clean up temp file
        try:
            Path(definition_path).unlink()
            logger.info("[Cura] Cleaned up temp definition file")
        except Exception as e:
            logger.warning("[Cura] Failed to cleanup temp file: %s", e)


async def convert_stl_to_gcode_with_db_profile(
    stl_path: str,
    gcode_path: str,
    printer_profile: Dict[str, any],
    custom_settings: Optional[Dict[str, str]] = None,
) -> bool:
    """
    Convert STL to G-code using printer profile from database.

    This function is designed to work when printer definitions are stored in DB
    instead of using local .def.json files.

    Args:
        stl_path: Absolute path to input STL file
        gcode_path: Absolute path to output G-code file
        printer_profile: Dictionary containing printer profile from DB with keys:
            - 'definition_json': Path to printer definition file OR JSON string
            - 'settings': Optional default settings for this printer
        custom_settings: Optional user settings to override printer defaults

    Returns:
        bool: Success status
    """
    # Extract definition path/content from profile
    definition = printer_profile.get('definition_json')
    printer_default_settings = printer_profile.get('settings', {})

    if not definition:
        raise RuntimeError("Printer profile missing 'definition_json'")

    # Handle if definition is a JSON string (stored in DB)
    definition_path = None
    if isinstance(definition, str) and definition.endswith('.json'):
        # It's a file path
        definition_path = definition
    elif isinstance(definition, (str, dict)):
        # It's JSON content - need to write to temp file
        import tempfile
        temp_def = tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.def.json',
            delete=False,
            dir=OUTPUT_DIR
        )
        if isinstance(definition, str):
            temp_def.write(definition)
        else:
            json.dump(definition, temp_def)
        temp_def.close()
        definition_path = temp_def.name
        logger.info("[Cura] Created temporary definition file: %s", definition_path)

    # Merge settings: defaults < printer defaults < custom settings
    merged_settings = DEFAULT_CURA_SETTINGS.copy()
    if printer_default_settings:
        merged_settings.update(printer_default_settings)
    if custom_settings:
        merged_settings.update(custom_settings)

    try:
        return await convert_stl_to_gcode(
            stl_path=stl_path,
            gcode_path=gcode_path,
            custom_settings=merged_settings,
            printer_definition_path=definition_path,
        )
    finally:
        # Clean up temp file if created
        if definition_path and 'temp' in definition_path:
            try:
                Path(definition_path).unlink()
                logger.info("[Cura] Cleaned up temp definition file")
            except Exception as e:
                logger.warning("[Cura] Failed to cleanup temp file: %s", e)
